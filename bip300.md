BIP-300 Functional Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be
interpreted as described in RFC 2119.

TODO: Reconsider the format.
TODO: Edit the specification to be in uniform style.

# M1. "Propose New Sidechain"

## Semantics

An M1 with sidechain slot number `S` and sidechain description `D` means:

I, someone who can include a message in the coinbase transaction of a valid
Bitcoin block, propose that a sidechain described by an array of bytes `D` be
activated in the sidechain slot defined by an unsigned integer `S`.

If the sidechain slot is `unused`, then I propose for it to be activated and
become `used` by the sidechain described by `D`.

After a sidechain slot is activated and so is `used`, it will be possible to
make deposit to and withdrawals from the sidechain described by `D`.

If the sidechain slot is `used`, then I propose for the sidechain it is
currently `used` by to be overwritten by a new sidechain described by `D`.

After the old sidechain is overwritten, it will no longer be officially
possible, as far as the BIP300 protocol is concerned, to make deposits to and
to make withdrawals from the old sidechain, the old sidechain software may do
whatever it wants in this new unofficial condition.

After the new sidechain overwrites the old one, it will be possible to make
deposits to and withdrawals from the new sidechain described by `D`.

The voting thresholds for overwriting a sidechain in `used` sidechain slot are
different form the voting thresholds for activating a sidechain in an `unused`
sidechain slot. The voting thresholds are defined in the section specifying M2
- ACK Sidechain Proposal.

## Definition

This message MUST include two pieces of data:

1. Sidechain slot number
2. Sidechain description

A sidechain slot number is an unsigned integer.

The exact representation of this integer in the actual M1 message is defined in
the subsequent Encoding section.

A sidechain description is an array of bytes.

The exact representation of this array of bytes in the actual M1 message is defined in
the subsequent Encoding section.

## Encoding
The M1 script MUST be included in an output of a coinbase transaction. An M1
script that is not an output of a coinbases transaction MUST be ignored.

It MUST only be possible for those who can modify the coinbase transaction,
miners and mining pools most likely, to propose a sidechain. If a regular
Bitcoin user can propose a sidechain in non coinbase transaction - that is a
violation of BIP300 protocol rules.

The value of the output containing an M1 message MUST be ignored. It MAY be 0
BTC, it MAY be 100 BTC, as far as the BIP300 protocol is concerned it doesn't
matter. Miners and mining pools are free to dispose of their funds as they
please.

```C++
class CTxOut
{
public:
    CAmount nValue; // nValue MUST be ignored. 
    CScript scriptPubKey; // M1 MUST be encoded in scriptPubKey.
// ...
}
```

An M1 script MUST take the following form:

```
OP_RETURN [0xD5, 0xE0, 0xC4, 0xAF] <S> <D>
```

Bitcoin script interpreter fails immediately upon seeing an OP_RETURN, meaning
that the output is unspendable no matter what comes after OP_RETURN.

For the purposes of BIP300 protocol we shall reinterpret the bytes following
an OP_RETURN as just bytes, not as Bitcoins script opcodes.

So the bytes after an OP_RETURN MUST be interpreted just as bytes with absolutely
no semantic connection to Bitcoin script.

If a scriptPubKey is an OP_RETURN = `0x6A` followed by the four bytes `[0xD5, 0xE0,
0xC4, 0xAF]`, then it MUST be interpreted as an M1 message.

So the boolean expression
```
   scriptPubKey[0] == 0x6A // OP_RETURN
&& scriptPubKey[1] == 0xD5
&& scriptPubKey[2] == 0xE0
&& scriptPubKey[3] == 0xC4
&& scriptPubKey[4] == 0xAF
```
evaluating to true means that it is an M1 message.

`[0x6A, 0xD5, 0xE0, 0xC4, 0xAF]` is the header of M1.

The header is followed by the body.

The body of M1 consists of two sequential parts: `S` and `D`.

`S` is the number of the sidechain slot to be activated, if it is `unused`, or
to be overwritten, if it is `used`.

`D` is an array of bytes describing the sidechain that will either be activated
in an `unused` slot or that will overwrite the old sidechain that was occupying
a `used` slot.

`S` is a single byte it is always the byte at index 5. So in pseudocode:
```
S = scriptPubKey[5]
```

`D` is an array consisting of all the bytes following `S`, so all the bytes
from index 6 (including the byte at index 6)  until the end of the script. In
pseudocode:
```
D = scriptPubKey[6..]
```

Length of `D` is unspecified here. In practice it is limited by Bitcoin
validation rules.

## Conditions

M1 MUST be a Bitcoin script valid under existing validation rules, meaning that
no matter what sidechain slot is chosen and no matter what the bytes in the
array of the sidechain description - a coinbase transaction containing an
output with an M1 encoded in its scriptpubkey MUST be accepted by ANY currently
deployed Bitcoin node with a reasonable configuration - including nodes that do
enforce BIP300 rules and the ones that don't both.

An analogous condition applies to ALL subsequent messages - to M2, M3, M4, M5,
M6.

# M2. "ACK Proposal"
## Semantics
An M2 message SHALL be interpreted as an ordinary script if any of the
following conditions hold:

* The M2 message is not within a coinbase output.
* The M2 message is NOT _well-formed_, ie. NOT composed of exactly `37` bytes.
* The `32`-byte proposal identifier does not match the sha256d digest of any
  sidechain proposal created via an M1 message in a previous block.

Otherwise, an M2 message is considered _valid_. 

If another _valid_ M2 message is included within any coinbase output at a lower
output index, the block is _invalid_ and MUST be _rejected_. Otherwise, a node
MUST increment the ACK counter for the sidechain proposal for which the sha256d
digest is referenced by the `32`-byte proposal identifier.

If any of the following conditions hold, activation for the specified sidechain
proposal _fails_:

* The sidechain proposal refers to an unused slot, and the sidechain proposal
  age is greater than `2_016` blocks
* The sidechain proposal refers to an unused slot, the sidechain proposal age
  is greater than `201` blocks, and the difference between the ACK counter for
  the proposal and the sidechain proposal age is not less than `201`.
* The sidechain proposal refers to a used slot, and the sidechain proposal age
  is greater than `26_300` blocks
* The sidechain proposal refers to an used slot, the sidechain proposal age is
  greater than `13501` blocks, and the difference between the ACK counter for
  the proposal and the sidechain proposal age is not less than `13501`.

If none of the conditions for failure are possible, the sidechain proposal
_succeeds_, and the sidechain described by the proposal is _activated_.

## Definition
## Encoding
M2 scripts are defined as scripts with the prefix `OP_RETURN [0xD6, 0xE1, 0xC5, 0xBF]`.
A _well-formed_ M2 script is defined as a script of the form
`OP_RETURN [0xD6, 0xE1, 0xC5, 0xBF] <ACK>` where `ACK` is exactly `32` bytes.

`ACK` is the sha256d hash of the sidechain proposal description `D`.

## Conditions
# M3. "Propose Bundle"
## Semantics
An M3 message SHALL be interpreted as an ordinary script if any of the
following conditions hold:
* The M3 message is not within a coinbase output.
* The M3 message is NOT _well-formed_, ie. NOT composed of exactly `38` bytes.
* The `1`-byte sidechain slot number does not correspond to a sidechain slot
  that is _active_.

Otherwise, an M3 message is considered _valid_.
If any of the following conditions hold, the block is considered _invalid_ and
MUST be _rejected_:
* The `32`-byte `M6ID` has already been proposed in an M3
  message in a previous block, that has not been paid out.
* Another _valid_ M3 message with an identical sidechain slot number is
  included within any coinbase output at a lower output index.

If a _valid_ M3 message does not cause a block to be considered _invalid_, a
node MUST initialize an ACK counter and expiry block height corresponding to
the pair consisting of the specified sidechain slot, and the  `32`-byte `M6ID`,
where the initial value of the ACK counter is `1`, and the initial value of the
expiry block height is the `26_299` greater than the block height of the block
that includes the M3 message.

## Definition
## Encoding
M3 scripts are defined as scripts with the prefix `OP_RETURN [0xD4, 0x5A, 0xA9,
0x43]`. A _well-formed_ M3 script is defined as a script of the form `OP_RETURN
[0xD4, 0x5A, 0xA9, 0x43] <COMMITMENT> <NSIDECHAIN>` where `COMMITMENT` is
exactly `32` bytes, and `NSIDECHAIN` is exactly `1` byte.

## Conditions
# M4. "Ack Bundle"
## Semantics

The block in which an `M6ID` has the number of votes greater than `13_150` MUST
include the corresponding `M6`, otherwise the block MUST be considered invalid.

Corresponding here means that `m6_to_id(M6) = M6ID`, where `m6_to_id` is the
function defined in the section specifying `M6`.

## Definition
## Encoding
## Conditions
# M5. "Deposit"

## Semantics
An M5 with sidechain slot number S, value V, and address A means:

I, a Bitcoin user with sufficient funds, deposit V sats to address A to the
sidechain in slot S. These V sats will no longer be available on the mainchain,
unless withdrawn using M6.

A treasury UTXO for slot S is a single UTXO in the Bitcoin UTXO set that holds
all funds currently in circulation on the sidechain in slot S.

An M5 is a Bitcoin transaction.

M5 for sidechain slot S MUST either create the first treasury UTXO for
sidechain slot S or, if it already exists, spend the treasury UTXO for
sidechain slot S.

There MUST never be two treasury UTXOs for the same sidechain slot.

## Definition
## Encoding

M5 MUST be a valid Bitcoin transaction.

M5 MUST have the following three parts:

1. treasury UTXO
2. address OP_RETURN output
3. input spending previous treasury UTXO (if it is not the first ever deposit
   to this sidechain)

Let us consider these three parts in turn.

### Treasury UTXO

Under BIP300 rules `OP_NOP5` is known as `OP_DRIVECHAIN`.

A treasury UTXO MUST have a `scriptPubKey` of the following form:

```
OP_DRIVECHAIN OP_PUSHBYTES_1 <S> OP_TRUE
```

S is a 1 byte sidechain slot number.

The nValue of a treasury UTXO for sidechain slot S MUST be equal to the total
amount of funds circulating in the sidechain active in sidechain slot S at all
times.

Let `n` be the sequence number of the deposit. The first ever deposit in a
sidechain will have sequence number `n = 0`, second one will have sequence
number `n = 1`, and so on.

So, in order to make a deposit of `V_n` sats to a sidechain we MUST first know
the current total amount of sats locked in the treasury UTXO we are spending,
let us call it `T_n` for total.

We can get `T_n` by looking up the `nValue` field of the treasury UTXO we are
spending in this M5 transaction. If we are making the first ever deposit, and
the treasury UTXO doesn't exist, we set `T_0 = 0`.

Then we MUST set the new total amount of sats locked in the newly created
treasury UTXO, let us call it `T_n+1` so `T_n+1 = T_n + V_n`.

```C++
class CTxOut
{
public:
    CAmount nValue; // T_n+1 = T_n + V
                    // where
                    // T_n+1 is new total,
                    // T_n is previous total,
                    // V is deposit value.
    CScript scriptPubKey; // MUST be a proper OP_DRIVECHAIN script.
// ...
}
```

An individual treasury UTXO by itself (with the exception of the first ever
deposit) does not supply enough data in order to recover the actual deposit
value `V_n`.

In order to recover `V_n = T_n+1 - T_n` we MUST know both `T_n+1` and `T_n`.

`T_n+1` is the `nValue` of the treasury UTXO created in the M5 transaction
encoding the `n`th deposit.

`T_n` is the `nValue` of the treasury UTXO spent in the M5 transaction encoding
the `n`th deposit.

### address OP_RETURN output

`nValue` of the address OP_RETURN output MUST be ignored, Bitcoin users are
free to dispose of their funds as they please.

An address OP_RETURN output MUST have a `scriptPubKey` of the following form

```
OP_RETURN <A>
```

Where `A` is an array of bytes encoding the sidechain address for the deposit.
Interpretation of `A` for a particular sidechain slot is up to the authors of the
sidechain active in that slot.

`A` MUST be interpreted by the BIP300 enforcer software as an arbitrary
meaningless array of bytes.

```C++
class CTxOut
{
public:
    CAmount nValue; // MUST be ignored.
    CScript scriptPubKey; // OP_RETURN <A>
// ...
}
```

An address OP_RETURN output MUST come immediately after the treasury UTXO in
the `vout` vector of the M5 transaction.

```C++
class CTransaction
{
    // ...
    const std::vector<CTxIn> vin;
    const std::vector<CTxOut> vout;
    // ...
}
```

So if a treasury UTXO is at the index 5 in the `vout` vector in the M5
transaction, then the corresponding address OP_RETURN output MUST be at the
index 6.

In pseudocode the following boolean expression MUST be true for any valid M5:
```
   vout[i] == OP_DRIVECHAIN OP_PUSHBYTES_1 <S> OP_TRUE
&& vout[i+1] == OP_RETURN <A>
```

If an M5 transaction has a UTXO treasury output and no address OP_RETURN
output, then it MUST be considered invalid by the BIP300 enforcer software.

### input spending previous UTXO treasury output

An M5 transaction MUST include an input spending the previous UTXO treasury
output in its `vin` vector. If it does not, it MUST be considered invalid.

The sidechain slot number `S` encoded in the previous treasury UTXO, which is
spent in this input of this M5 transaction MUST match the sidechain slot number
`S'` encoded in the new treasury UTXO created by this M5 transaction.

### Recovering the `n`th deposit from the M5 messages

An `n`th deposit for sidechain slot `S` has three parts:

1. `S` - the sidechain slot number.
2. `V_n` - the value to be deposited in sats.
3. `A_n` - the sidechain address for the deposit.

In order to recover a deposit in a form usable by sidechain software we must
know all three.

The deposit with `n = 0` is special, because we can get all three parts from a
single Bitcoin transaction: `M5_0` - the first ever deposit to be made in this
slot.

This `M5_0` transaction has two special outputs in its `vout` vector.

```C++
class CTransaction
{
    // ...
    const std::vector<CTxIn> vin; // Nothing here.
    const std::vector<CTxOut> vout; // Two outputs with all three parts.
    // ...
}
```

The first output is the first treasury UTXO.

```C++
class CTxOut
{
public:
    CAmount nValue; // Equal to T_1.
    CScript scriptPubKey; // Sidechain slot number S is encoded here.
// ...
}
```

Its `nValue` is equal to `T_1`, and because `V_0 = T_1 - T_0` and `T_0 = 0` we
know that `V_0 = T_1`.

Its `scriptPubKey` encodes the sidechain slot number `S` with the
`OP_DRIVECHAIN` script:

```
OP_DRIVECHAIN OP_PUSHBYTES_1 <S> OP_TRUE
```

Now we know `V_0` and `S`.

Immediately at the index in the `vout` vector after the treasury UTXO comes the
address OP_RETURN output.

```C++
class CTxOut
{
public:
    CAmount nValue; // MUST be ignored.
    CScript scriptPubKey; // OP_RETURN <A_0>
// ...
}
```

We know `S`, `T_1`, and `A_0`.
We can compute `V_0 = T_1 - T_0 = T_1 - 0 = T_1`.
Now we know all three parts we need `S`, `V_0`, and `A_0`.

So we have recovered the `n = 0` deposit made to the sidechain slot `S`.

A deposit with `n > 0` is different, in order to recover it we shall need two
Bitcoin transactions `M5_n` and `M5_n-1`.

We can get `S`, `A_n`, and `T_n+1` from `M5_n`.
We can get `T_n` from `M5_n-1`.
Then we can get `V_n = T_n+1 - T_n`.

So each deposit with `n > 0` is encoded by a pair of Bitcoin transactions.

```
      M5_0 -- n = 0
M5_0, M5_1 -- n = 1
M5_1, M5_2 -- n = 2
M5_2, M5_3 -- n = 3
M5_3, M5_4 -- n = 4
...
```

///
TODO: Specify how M6 withdrawal bundles, which have `T_n < T_n-1`, are to be
handled. Do we skip them, so the deposit sequence numbers remain continuous, or
do we count them, so there are gaps in the deposit sequence numbers?

I think it makes more sense to count them, so we know at which sequence number
a withdrawal happened.

If we attempt to look up a deposit at a withdrawal sequence number, the BIP300
enforcer deposits database would just say "a withdrawal happened at this
sequence number".

It would also make sense to store mainchain block height, at which M5 or M6 was
included, alongside the corresponding sequence number in the BIP300 enforcer
database.
///

It is also important to keep track of `n` - the deposit sequence number, so in
the end we have four parts `n`, `S`, `V_n`, `A_n`.

It would make sense for the BIP300 enforcer software to keep a database
containing `n`, `S`, `V_n`, and `A_n` for all deposits across all active
sidechain slots, because otherwise we would have to rescan the whole Bitcoin
blockchain every time we need to look up a deposit.

It would also make sense for the BIP300 enforcer software to keep track of last
`T_n` for every sidechain slot `S`, so whenever it receives `M5_n` encoding
`S`, `T_n+1`, and `A_n` it can compute `V_n = T_n+1 - T_n` and thus get all
four parts `n`, `S`, `V_n`, and `A_n` it needs in order to update its deposits
database.

### Conclusion

An M5 transaction MUST include two outputs: a treasury UTXO output and an
address OP_RETURN output. The address OP_RETURN output MUST be placed right
after the treasury UTXO output in the M5 transaction's `vout` vector.

If a treasury UTXO for this sidechain slot does not exist, then an M5
transaction MUST NOT include an input spending the previous treasury UTXO (as
it doesn't exist).

The `nValue` of this phantom non-existent treasury UTXO MUST be set to 0, so
when a sidechain is first activated in a slot it has exactly 0 sats in
circulation.

If a treasury UTXO for this sidechain slot does exist, then an M5 transaction
MUST include one input spending the previous treasury UTXO.

The `nValue` of the actual previous treasury UTXO must be looked up in order to
get the total amount of sats in circulation for the sidechain active in the
slot.

The `nValue` of the newly created treasury UTXO MUST be greater than the
`nValue` of the spent treasury UTXO, so when we deposit funds to a sidechain,
we increase the amount of funds in circulation for that sidechain.

??? QUESTION: What happens to the treasury UTXO when a `used` sidechain slot is
overwritten with a different sidechain?

Does the same chain of treasury UTXOs continue?

## Conditions
# M6. "Withdrawal Bundle"
## Semantics
An M6 is an aggregate of withdrawals 

```
[(Bitcoin address, value)]
```

Where `S` is the sidechain slot number and `C` is the withdrawals commitment.
## Definition
## Encoding
An M6 MUST be a valid Bitcoin transaction.

An M6 MUST have only one input. This one input MUST spend the treasury UTXO for
the sidechain from which the withdrawal is made.

An M6 MUST have an output with the new treasury UTXO.

This one newly created treasury UTXO MUST be located at index 0 in the `vout`
vector of the M6 transaction.

The sidechain slot number `S` encoded in the new treasury UTXO MUST match the
sidechain slot number `S` encoded in the spent treasury UTXO.

```C++
class CTxOut
{
public:
    CAmount nValue; // MUST be T_n = T_n-1 - P_total - F_total.
    CScript scriptPubKey; // OP_DRIVECHAIN OP_PUSHBYTES_1 <S> OP_TRUE
// ...
}
```

Where `T_n` is the `nValue` for the treasury UTXO created in this M6, `T_n-1`
is the `nValue` of treasury UTXO spent by this M6, `P_total` is the total
amount paid out in this withdrawal bundle, and `F_total` is the total amount of
fees paid to the miners in this withdrawal bundle.

After the new treasury UTXO at index 0 of the `vout` vector of the M6
withdrawal bundle transaction come the actual withdrawal pay out outputs.

```C++
class CTransaction
{
    // ...
    const std::vector<CTxIn> vin; // MUST have exactly one input spending
                                  // previous treasury UTXO.

    const std::vector<CTxOut> vout; // MUST have the new treasury UTXO at index 0.
                                    // This one special output is followed
                                    // by actual withdrawal pay out outputs.
    // ...
}
```

The amount of funds locked in the newly created treasury UTXO MUST be less than
the amount of funds locked in the spent treasury UTXO by exactly `P_total +
F_total`.

### The `m6_to_id` function definition

The `m6_to_id` function MUST be pure, meaning it MUST have no side effects.

The `m6_to_id` function takes two arguments: a valid `M6` Bitcoin transaction
and `T_n-1`, the value locked in the treasury UTXO spent in this `M6`.

The `m6_to_id` returns either `None` if any of its arguments are invalid or
`Some(M6ID)`, where `M6ID` is a 32 byte byte array.

We can't use the simple `txid` of the actual `M6` as the `M6ID`, because when
an `M6` withdrawal bundle is proposed with an `M3`, the treasury UTXO, which
must be spent by the actual `M6` when its `M6ID` reaches `13_151` votes (per
`M4` specification) most likely does not yet exist.

So we MUST compute the `txid` of something called `M6_blinded`.

`M6_blinded` differs from an actual `M6` in two ways:

1. The `vin` vector of `M6_blinded` MUST be empty, whereas the `vin` of `M6`
   includes the treasury UTXO, current at the block when this `M6` must be
   included (this is specified in the section on `M4`).
2. The last element in the `vout` vector of `M6_blinded` MUST be an output with
   `nValue = 0` and `scriptPubKey = OP_RETURN F_total_be_bytes`, where
   `F_total_be_bytes` is the 64 bit unsigned integer `F_total` (total amount of
   fess paid to the miners by this M6) encoded as an array of 8 bytes in big
   endian order.


So the `M6ID` is computed in three steps:

1. Remove the treasury UTXO input.
2. Add the `OP_RETURN` script with `F_total`.
3. Compute the `txid` of the resulting `M6_blinded` Bitcoin transaction, this
   `txid` is the `M6ID`.

In more detail:

`M6ID` MUST be computed by `m6_to_id` using the following steps:

1. Remove the single input spending the previous treasury UTXO from the `vin`
   vector, so that the `vin` vector is empty.
2. Compute `P_total` by summing the `nValue`s of all pay out outputs in this
   `M6`, so `P_total` = sum of `nValue`s of all outputs of this `M6` except for
   the new treasury UTXO at index 0.
3. Set `T_n` equal to the `nValue` of the treasury UTXO created in this `M6`.
4. Compute `F_total = T_n-1 - F_n - P_total`, since we know that `T_n = T_n-1 -
   P_total - F_total`, `T_n-1` was passed as an argument, and `T_n` and
   `P_total` were computed in previous steps..
5. Encode `F_total` as `F_total_be_bytes`, an array of 8 bytes encoding the 64
   bit unsigned integer in big endian order.
6. Push an output to the end of `vout` of this `M6` with the `nValue = 0` and
   `scriptPubKey = OP_RETURN F_total_be_bytes`.
```C++
class CTxOut
{
public:
    CAmount nValue; // MUST equal 0.
    CScript scriptPubKey; // OP_RETURN F_total_be_bytes
// ...
}
```
At this point we have constructed `M6_blinded`.

7. Compute `M6ID = txid(M6_blinded)`.

## Conditions
