BIP-300 Functional Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be
interpreted as described in RFC 2119.

TODO: Reconsider the format.
TODO: Edit the specification to be in uniform style.

# M1. "Propose New Sidechain"

## Semantics

An M1 with sidechain slot number `S` and sidechain description `D` means:

I, someone who can include a message in the coinbase transaction of a valid
Bitcoin block, propose that a sidechain described by an array of bytes `D` be
activated in the sidechain slot defined by an unsigned integer `S`.

If the sidechain slot is `unused`, then I propose for it to be activated and
become `used` by the sidechain described by `D`.

After a sidechain slot is activated and so is `used`, it will be possible to
make deposit to and withdrawals from the sidechain described by `D`.

If the sidechain slot is `used`, then I propose for the sidechain it is
currently `used` by to be overwritten by a new sidechain described by `D`.

After the old sidechain is overwritten, it will no longer be officially
possible, as far as the BIP300 protocol is concerned, to make deposits to and
to make withdrawals from the old sidechain, the old sidechain software may do
whatever it wants in this new unofficial condition.

After the new sidechain overwrites the old one, it will be possible to make
deposits to and withdrawals from the new sidechain described by `D`.

The voting thresholds for overwriting a sidechain in `used` sidechain slot are
different form the voting thresholds for activating a sidechain in an `unused`
sidechain slot. The voting thresholds are defined in the section specifying M2
- ACK Sidechain Proposal.

## Definition

This message MUST include two pieces of data:

1. Sidechain slot number
2. Sidechain description

A sidechain slot number is an unsigned integer.

The exact representation of this integer in the actual M1 message is defined in
the subsequent Encoding section.

A sidechain description is an array of bytes.

The exact representation of this array of bytes in the actual M1 message is defined in
the subsequent Encoding section.

## Encoding
The M1 script MUST be included in an output of a coinbase transaction. An M1
script that is not an output of a coinbases transaction MUST be ignored.

It MUST only be possible for those who can modify the coinbase transaction,
miners and mining pools most likely, to propose a sidechain. If a regular
Bitcoin user can propose a sidechain in non coinbase transaction - that is a
violation of BIP300 protocol rules.

The value of the output containing an M1 message MUST be ignored. It MAY be 0
BTC, it MAY be 100 BTC, as far as the BIP300 protocol is concerned it doesn't
matter. Miners and mining pools are free to dispose of their funds as they
please.

```C++
class CTxOut
{
public:
    CAmount nValue; // nValue MUST be ignored. 
    CScript scriptPubKey; // M1 MUST be encoded in scriptPubKey.
// ...
}
```

An M1 script MUST take the following form:

```
OP_RETURN [0xD5, 0xE0, 0xC4, 0xAF] <S> <D>
```

Bitcoin script interpreter fails immediately upon seeing an OP_RETURN, meaning
that the output is unspendable no matter what comes after OP_RETURN.

For the purposes of BIP300 protocol we shall reinterpret the bytes following
an OP_RETURN as just bytes, not as Bitcoins script opcodes.

So the bytes after an OP_RETURN MUST be interpreted just as bytes with absolutely
no semantic connection to Bitcoin script.

If a scriptPubKey is an OP_RETURN = `0x6A` followed by the four bytes `[0xD5, 0xE0,
0xC4, 0xAF]`, then it MUST be interpreted as an M1 message.

So the boolean expression
```
   scriptPubKey[0] == 0x6A // OP_RETURN
&& scriptPubKey[1] == 0xD5
&& scriptPubKey[2] == 0xE0
&& scriptPubKey[3] == 0xC4
&& scriptPubKey[4] == 0xAF
```
evaluating to true means that it is an M1 message.

`[0x6A, 0xD5, 0xE0, 0xC4, 0xAF]` is the header of M1.

The header is followed by the body.

The body of M1 consists of two sequential parts: `S` and `D`.

`S` is the number of the sidechain slot to be activated, if it is `unused`, or
to be overwritten, if it is `used`.

`D` is an array of bytes describing the sidechain that will either be activated
in an `unused` slot or that will overwrite the old sidechain that was occupying
a `used` slot.

`S` is a single byte it is always the byte at index 5. So in pseudocode:
```
S = scriptPubKey[5]
```

`D` is an array consisting of all the bytes following `S`, so all the bytes
from index 6 (including the byte at index 6)  until the end of the script. In pseudocode:
```
D = scriptPubKey[6..]
```

Length of `D` is unspecified here. In practice it is limited by Bitcoin
validation rules.

## Conditions

M1 MUST be a Bitcoin script valid under existing validation rules, meaning that
no matter what sidechain slot is chosen and no matter what the bytes in the
array of the sidechain description - a coinbase transaction containing an
output with an M1 encoded in its scriptpubkey MUST be accepted by ANY currently
deployed Bitcoin node with a reasonable configuration - including nodes that do
enforce BIP300 rules and the ones that don't both.

An analogous condition applies to ALL subsequent messages - to M2, M3, M4, M5,
M6.

# M2. "ACK Proposal"
## Semantics
An M2 message SHALL be interpreted as an ordinary script if any of the
following conditions hold:

* The M2 message is not within a coinbase output.
* The M2 message is NOT _well-formed_, ie. NOT composed of exactly `37` bytes.
* The `32`-byte proposal identifier does not match the sha256d digest of any
  sidechain proposal created via an M1 message in a previous block.

Otherwise, an M2 message is considered _valid_. 

If another _valid_ M2 message is included within any coinbase output at a lower
output index, the block is _invalid_ and MUST be _rejected_. Otherwise, a node
MUST increment the ACK counter for the sidechain proposal for which the sha256d
digest is referenced by the `32`-byte proposal identifier.

If any of the following conditions hold, activation for the specified sidechain
proposal _fails_:

* The sidechain proposal refers to an unused slot, and the sidechain proposal
  age is greater than `2_016` blocks
* The sidechain proposal refers to an unused slot, the sidechain proposal age
  is greater than `201` blocks, and the difference between the ACK counter for
  the proposal and the sidechain proposal age is not less than `201`.
* The sidechain proposal refers to a used slot, and the sidechain proposal age
  is greater than `26_300` blocks
* The sidechain proposal refers to an used slot, the sidechain proposal age is
  greater than `13501` blocks, and the difference between the ACK counter for
  the proposal and the sidechain proposal age is not less than `13501`.

If none of the conditions for failure are possible, the sidechain proposal
_succeeds_, and the sidechain described by the proposal is _activated_.

## Definition
## Encoding
M2 scripts are defined as scripts with the prefix `OP_RETURN [0xD6, 0xE1, 0xC5, 0xBF]`.
A _well-formed_ M2 script is defined as a script of the form
`OP_RETURN [0xD6, 0xE1, 0xC5, 0xBF] <ACK>` where `ACK` is exactly `32` bytes.

`ACK` is the sha256d hash of the sidechain proposal description `D`.

## Conditions
# M3. "Propose Bundle"
## Semantics
An M3 message SHALL be interpreted as an ordinary script if any of the
following conditions hold:
* The M3 message is not within a coinbase output.
* The M3 message is NOT _well-formed_, ie. NOT composed of exactly `38` bytes.
* The `1`-byte sidechain slot number does not correspond to a sidechain slot
  that is _active_.

Otherwise, an M3 message is considered _valid_.
If any of the following conditions hold, the block is considered _invalid_ and MUST be _rejected_:
* The `32`-byte withdrawal bundle commitment has already been proposed in an M3
  message in a previous block, that has not been paid out.
* Another _valid_ M3 message with an identical sidechain slot number is
  included within any coinbase output at a lower output index.

If a _valid_ M3 message does not cause a block to be considered _invalid_, a
node MUST initialize an ACK counter and expiry block height corresponding to
the pair consisting of the specified sidechain slot, and the  `32`-byte
withdrawal bundle commitment, where the initial value of the ACK counter is
`1`, and the initial value of the expiry block height is the `26_299` greater
than the block height of the block that includes the M3 message.

## Definition
## Encoding
M3 scripts are defined as scripts with the prefix `OP_RETURN [0xD4, 0x5A, 0xA9,
0x43]`. A _well-formed_ M3 script is defined as a script of the form `OP_RETURN
[0xD4, 0x5A, 0xA9, 0x43] <COMMITMENT> <NSIDECHAIN>` where `COMMITMENT` is
exactly `32` bytes, and `NSIDECHAIN` is exactly `1` byte.

## Conditions
# M4. "Ack Bundle"
## Semantics
## Definition
## Encoding
## Conditions
# M5. "Deposit"

TODO: Specify how M6 withdrawal bundles, which have `T_n < T_n-1`, are to be
handled.

## Semantics
An M5 with sidechain slot number S, value V, and address A means:

I, a Bitcoin user with sufficient funds, deposit V sats to address A to the
sidechain in slot S. These V sats will no longer be available on the mainchain,
unless withdrawn using M6.

A treasury UTXO for slot S is a single UTXO in the Bitcoin UTXO set that holds
all funds currently in circulation on the sidechain in slot S.

An M5 is a Bitcoin transaction.

M5 for sidechain slot S MUST either create the first treasury UTXO for
sidechain slot S or, if it already exists, spend the treasury UTXO for
sidechain slot S.

There MUST never be two treasury UTXOs for the same sidechain slot.

## Definition
## Encoding

M5 MUST be a valid Bitcoin transaction.

M5 MUST have the following three parts:

1. treasury UTXO
2. address OP_RETURN output
3. input spending previous treasury UTXO (if it is not the first ever deposit
   to this sidechain)

Let us consider these three parts in turn.

### Treasury UTXO

Under BIP300 rules `OP_NOP5` is known as `OP_DRIVECHAIN`.

A treasury UTXO MUST have a `scriptPubKey` of the following form:

```
OP_DRIVECHAIN OP_PUSHBYTES_1 <S> OP_TRUE
```

S is a 1 byte sidechain slot number.

The nValue of a treasury UTXO for sidechain slot S MUST be equal to the total
amount of funds circulating in the sidechain active in sidechain slot S at all
times.

Let `n` be the sequence number of the deposit. The first ever deposit in a
sidechain will have sequence number `n = 0`, second one will have sequence
number `n = 1`, and so on.

So, in order to make a deposit of `V_n` sats to a sidechain we MUST first know
the current total amount of sats locked in the treasury UTXO we are spending,
let us call it `T_n` for total.

We can get `T_n` by looking up the `nValue` field of the treasury UTXO we are
spending in this M5 transaction. If we are making the first ever deposit, and
the treasury UTXO doesn't exist, we set `T_0 = 0`.

Then we MUST set the new total amount of sats locked in the newly created
treasury UTXO, let us call it `T_n+1` so `T_n+1 = T_n + V_n`.

```C++
class CTxOut
{
public:
    CAmount nValue; // T_n+1 = T_n + V
                    // where
                    // T_n+1 is new total,
                    // T_n is previous total,
                    // V is deposit value.
    CScript scriptPubKey; // MUST be a proper OP_DRIVECHAIN script.
// ...
}
```

An individual treasury UTXO by itself (with the exception of the first ever
deposit) does not supply enough data in order to recover the actual deposit
value `V_n`.

In order to recover `V_n = T_n+1 - T_n` we MUST know both `T_n+1` and `T_n`.

`T_n+1` is the `nValue` of the treasury UTXO created in the M5 transaction
encoding the `n`th deposit.

`T_n` is the `nValue` of the treasury UTXO spent in the M5 transaction encoding
the `n`th deposit.

### address OP_RETURN output

`nValue` of the address OP_RETURN output MUST be ignored, Bitcoin users are
free to dispose of their funds as they please.

An address OP_RETURN output MUST have a `scriptPubKey` of the following form

```
OP_RETURN <A>
```

Where `A` is an array of bytes encoding the sidechain address for the deposit.
Interpretation of `A` for a particular sidechain slot is up to the authors of the
sidechain active in that slot.

`A` MUST be interpreted by the BIP300 enforcer software as an arbitrary
meaningless array of bytes.

```C++
class CTxOut
{
public:
    CAmount nValue; // MUST be ignored.
    CScript scriptPubKey; // OP_RETURN <A>
// ...
}
```

An address OP_RETURN output MUST come immediately after the treasury UTXO in
the `vout` vector of the M5 transaction.

```C++
class CTransaction
{
    // ...
    const std::vector<CTxIn> vin;
    const std::vector<CTxOut> vout;
    // ...
}
```

So if a treasury UTXO is at the index 5 in the `vout` vector in the M5
transaction, then the corresponding address OP_RETURN output MUST be at the
index 6.

In pseudocode the following boolean expression MUST be true for any valid M5:
```
   vout[i] == OP_DRIVECHAIN OP_PUSHBYTES_1 <S> OP_TRUE
&& vout[i+1] == OP_RETURN <A>
```

If an M5 transaction has a UTXO treasury output and no address OP_RETURN
output, then it MUST be considered invalid by the BIP300 enforcer software.

### input spending previous UTXO treasury output

An M5 transaction MUST include an input spending the previous UTXO treasury
output in its `vin` vector. If it does not, it MUST be considered invalid.

The sidechain slot number `S` encoded in the previous treasury UTXO, which is
spent in this input of this M5 transaction MUST match the sidechain slot number
`S'` encoded in the new treasury UTXO created by this M5 transaction.

### Recovering the `n`th deposit from the M5 messages

An `n`th deposit for sidechain slot `S` has three parts:

1. `S` - the sidechain slot number.
2. `V_n` - the value to be deposited in sats.
3. `A_n` - the sidechain address for the deposit.

In order to recover a deposit in a form  usable sidechain software we must know
all three.

The deposit with `n = 0` is special, because we can get all three parts from a
single Bitcoin transaction: `M5_0` - the first ever deposit to be made in this
slot.

This `M5_0` transaction has two special outputs in its `vout` vector.

```C++
class CTransaction
{
    // ...
    const std::vector<CTxIn> vin; // Nothing here.
    const std::vector<CTxOut> vout; // Two outputs with all three parts.
    // ...
}
```

The first output is the first treasury UTXO.

```C++
class CTxOut
{
public:
    CAmount nValue; // Equal to T_1.
    CScript scriptPubKey; // Sidechain slot number S is encoded here.
// ...
}
```

Its `nValue` is equal to `T_1`, and because `V_0 = T_1- T_0` and `T_0 = 0` we
know that `V_0 = T_1`.

Its `scriptPubKey` encodes the sidechain slot number `S` with the
`OP_DRIVECHAIN` script:

```
OP_DRIVECHAIN OP_PUSHBYTES_1 <S> OP_TRUE
```

Now we know `V_0` and `S`.

Immediately at the index in the `vout` vector after the treasury UTXO comes the
address OP_RETURN output.

```C++
class CTxOut
{
public:
    CAmount nValue; // MUST be ignored.
    CScript scriptPubKey; // OP_RETURN <A_0>
// ...
}
```

We know `S`, `T_1`, and `A_0`.
We can compute `V_0 = T_1 - T_0 = T_1 - 0 = T_1`.
Now we know all three parts we need `S`, `V_0`, and `A_0`.

So we have recovered the `n = 0` deposit made to the sidechain slot `S`.

A deposit with `n > 0` is different, in order to recover it we shall need two
Bitcoin transactions `M5_n` and `M5_n-1`.

We can get `S`, `A_n`, and `T_n+1` from `M5_n`.
We can get `T_n` from `M5_n-1`.
Then we can get `V_n = T_n+1 - T_n`.

So each deposit with `n > 0` is encoded by a pair of Bitcoin transactions.

```
      M5_0 -- n = 0
M5_0, M5_1 -- n = 1
M5_1, M5_2 -- n = 2
M5_2, M5_3 -- n = 3
M5_3, M5_4 -- n = 4
...
```

It would make sense for the BIP300 enforcer software to keep a database
containing `S`, `V_n`, and `A_n` for all deposits across all active sidechain
slots, because otherwise we would have to rescan the whole Bitcoin blockchain
every time we need to look up a deposit.

It would also make sense for the BIP300 enforcer software to keep track of last
`T_n` for every sidechain slot `S`, so whenever it receives `M5_n` encoding
`S`, `T_n+1`, and `A_n` it can compute `V_n = T_n+1 - T_n` and thus get all
three parts `S`, `V_n`, and `A_n` it needs in order to update its deposits
database.

### Conclusion

An M5 transaction MUST include two outputs: a treasury UTXO output and an
address OP_RETURN output. The address OP_RETURN output MUST be placed right
after the treasury UTXO output in the M5 transaction's `vout` vector.

If a treasury UTXO for this sidechain slot does not exist, then an M5
transaction MUST NOT include an input spending the previous treasury UTXO (as
it doesn't exist).

The `nValue` of this phantom non-existent treasury UTXO MUST be set to 0, so
when a sidechain is first activated in a slot it has exactly 0 sats in
circulation.

If a treasury UTXO for this sidechain slot does exist, then an M5 transaction
MUST include one input spending the previous treasury UTXO.

The `nValue` of the actual previous treasury UTXO must be looked up in order to
get the total amount of sats in circulation for the sidechain active in the
slot.

The `nValue` of the newly created treasury UTXO MUST be greater than the
`nValue` of the spent treasury UTXO, so when we deposit funds to a sidechain,
we increase the amount of funds in circulation for that sidechain.

??? QUESTION: What happens to the treasury UTXO when a `used` sidechain slot is
overwritten with a different sidechain?

Does the same chain of treasury UTXOs continue?

## Conditions
# M6. "Withdrawal Bundle"
## Semantics
An M6 is an aggregate of withdrawals 

```
[(Bitcoin address, value)]
```

Where `S` is the sidechain slot number and `C` is the withdrawals commitment.
## Definition
## Encoding
An M6 MUST be a valid Bitcoin transaction.

An M6 MUST have only one input.
This one input MUST spend the treasury UTXO for the sidechain from which the
withdrawal is made.

An M6 MUST have an output with the new treasury UTXO.

This one newly created treasury UTXO MUST be located at index 0 in the `vout`
vector of the M6 transaction.

The sidechain slot number `S` encoded in the new treasury UTXO MUST match the
sidechain slot number `S` encoded in the spent treasury UTXO.

```C++
class CTxOut
{
public:
    CAmount nValue; // MUST be T_n = T_n-1 - P_total.
    CScript scriptPubKey; // OP_DRIVECHAIN OP_PUSHBYTES_1 <S> OP_TRUE
// ...
}
```

Where `T_n` is the `nValue` for the treasury UTXO created in this M6, `T_n-1`
is the `nValue` of treasury UTXO spent by this M6, and `P_total` is the total
amount paid out in this withdrawal bundle.

An M6 MUST have a withdrawals commitment OP_RETURN output at index 1 of its
`vout` vector.

A withdrawals commitment MUST commit to the set of sidechain withdrawals
bundled in this withdrawal bundle M6.

It MUST be possible, given a sidechain withdrawals set `WS` and an M6
withdrawal bundle `WB` (which includes the withdrawals commitment OP_RETURN),
to check if this specific `WB` actually bundles this specific `WS`.

Without the withdrawals commitment it would be possible for two different
`WS`es to be bundled into the exact same `WB`.

For example, if there is no withdrawals commitment:

Let Alice spend her sidechain output `SO_alice` to create a withdrawal of 1 BTC
to bitcoin address `BA`. Then let us bundle this single withdrawal into an M6
withdrawal bundle `WB`.

Let Bob spend his sidechain output `SO_bob` to create a withdrawal of 1 BTC
to bitcoin address `BA`. Then let us bundle this single withdrawal into an M6
withdrawal bundle `WB`.

In both cases this `WB` would be byte by byte identical, it would spend the
exact same treasury UTXO, it would create the exact same new treasury UTXO, and
it would have the exact same output paying out 1 BTC to bitcoin address `BA`.

So it would be impossible to determine whether Alice's output `SO_alice` or
Bob's output `SO_bob` was spent in this `WB`.

But if we do have a withdrawals commitment, then we would get two distinct M6
withdrawal bundles `WB_alice` with an OP_RETURN committing to `SO_alice` and
`WB_bob` with an OP_RETURN committing to `SO_bob`.

Note that this is just an example, and a single withdrawal is made in each case
only to make it easier to illustrate a point. In practice there would be more
than one withdrawal in an M6 withdrawal bundle.

////
TODO: Determine which cryptographic primitive exactly to use for the
withdrawals commitment.

A merkle tree?

It would be helpful if it was easy to check, given a particular withdrawal `W`
and a withdrawals commitment `WC` if `W` is one of the withdrawals `WC` commits
to.

A good cryptographic accumulator would be ideal.

It would make sense to leave this decision to sidechain authors.
////

A withdrawals commitment OP_RETURN output MUST have a `scriptPubKey` of the
following form:

```
OP_RETURN <WC>
```

The BIP300 enforcer MUST interpret `WC` as a meaningless array of bytes.

It is up to sidechain authors to determine which cryptographic primitive to use
for the withdrawals commitment.

`nValue` of the withdrawals commitment OP_RETURN MUST be 0.

```C++
class CTxOut
{
public:
    CAmount nValue; // MUST be 0.
    CScript scriptPubKey; // OP_RETURN <WC>
// ...
}
```

After the new treasury UTXO at index 0 and the withdrawals commitment OP_RETURN
at index 1 in the `vout` vector of the M6 withdrawal bundle transaction come
the actual withdrawal pay out outputs.

```C++
class CTransaction
{
    // ...
    const std::vector<CTxIn> vin; // MUST have exactly one input spending
                                  // previous treasury UTXO.

    const std::vector<CTxOut> vout; // MUST have the new treasury UTXO at index 0.
                                    // MUST have a withdrawals commitment OP_RETURN at index 1.
                                    // These two special outputs are followed
                                    // by actual withdrawal pay out outputs.
    // ...
}
```

Let us call the sum of `nValue`s of all pay out outputs in this M6 withdrawal
bundle `P_total` for total pay out.

The amount of funds locked in the newly created treasury UTXO MUST be less than
the amount of funds locked in the spent treasury UTXO by exactly `P_total`.

??? QUESTION: Would it make sense for the M6 withdrawal bundle transaction to
pay 0 fees to the miners?

The sidechain users withdrawing the funds have already paid the fees (which
ultimately get to the Bitcoin miners per BIP301) for including their withdrawal
requests in the sidechain block.

Why should they pay a separate fee through a different mechanism?

If M6 pays no fees to the miners, then we can remove quite a bit of code in
both the BIP300 enforcer implementation and in the sidechain implementations.

## Conditions
